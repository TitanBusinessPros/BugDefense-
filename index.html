None selected

Skip to content
Using Gmail with screen readers
Conversations
8% of 15 GB used
Terms ¬∑ Privacy ¬∑ Program Policies
Last account activity: 13 minutes ago
Details
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bug Defense - Tower Defense Game</title>
    
    <!-- Favicon - Replace with your GitHub raw PNG link -->
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/yourusername/yourrepo/main/assets/favicon.png">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a6c1a, #1f8b1f, #b2fd2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            position: relative;
        }
        
        .audio-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .audio-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.3s;
        }
        
        .audio-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .game-stats {
            display: flex;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .game-area {
            display: flex;
            gap: 20px;
        }
        
        .game-board {
            flex: 3;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .controls {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
        }
        
        .tower-selection {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .tower-option {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        
        .tower-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .tower-option.selected {
            background: rgba(255, 215, 0, 0.3);
            border: 2px solid gold;
        }
        
        .tower-icon {
            width: 60px;
            height: 60px;
            margin: 0 auto 5px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        
        button {
            background: linear-gradient(to bottom, #4a90e2, #2c5aa0);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            font-size: 1.1rem;
        }
        
        button:hover {
            background: linear-gradient(to bottom, #5a9fed, #3c6ab0);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #grid-container {
            position: relative;
            width: 600px;
            height: 600px;
            background: rgba(0, 0, 0, 0.2);
        }
        
        .grid-cell {
            position: absolute;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.2s;
        }
        
        .grid-cell.path {
            background: rgba(139, 69, 19, 0.7);
        }
        
        .grid-cell.grass {
            background: rgba(34, 139, 34, 0.3);
        }
        
        .grid-cell.valid {
            background: rgba(144, 238, 144, 0.6);
            cursor: pointer;
        }
        
        .grid-cell.invalid {
            background: rgba(255, 99, 71, 0.4);
            cursor: not-allowed;
        }
        
        .tower {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transform-origin: center;
            pointer-events: none;
        }
        
        .tower.range-display {
            border: 2px dashed rgba(255, 255, 255, 0.5);
            background: transparent;
            z-index: 5;
            pointer-events: none;
        }
        
        .enemy {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 15;
            transition: left 0.1s linear, top 0.1s linear;
            pointer-events: none;
        }
        
        .enemy.slowed {
            animation: pulse-slow 1s infinite;
        }
        
        .projectile {
            position: absolute;
            border-radius: 50%;
            z-index: 12;
            pointer-events: none;
            transition: all 0.1s linear;
        }
        
        .projectile.bullet {
            width: 6px;
            height: 6px;
            background: #4CAF50;
        }
        
        .projectile.sniper {
            width: 4px;
            height: 12px;
            background: #2196F3;
            border-radius: 2px;
        }
        
        .projectile.cannon {
            width: 15px;
            height: 15px;
            background: #FF9800;
            animation: cannon-spin 0.5s linear infinite;
        }
        
        .projectile.freeze {
            width: 8px;
            height: 8px;
            background: #00BCD4;
            animation: freeze-pulse 0.3s infinite;
        }
        
        .explosion {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, #FF9800, #FF5722, transparent);
            z-index: 14;
            pointer-events: none;
            animation: explode 0.3s forwards;
        }
        
        .health-bar {
            position: absolute;
            bottom: -5px;
            left: 5%;
            width: 90%;
            height: 3px;
            background: #333;
            z-index: 16;
        }
        
        .health-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }
        
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: 10px;
        }
        
        .hidden {
            display: none;
        }
        
        .wave-info {
            margin-top: 20px;
            text-align: center;
        }
        
        .instructions {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 0.9rem;
        }
        
        .placement-help {
            background: rgba(255, 215, 0, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            border-left: 3px solid gold;
        }
        
        .upgrade-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .upgrade-btn {
            background: linear-gradient(to bottom, #9c27b0, #7b1fa2);
            margin: 5px 0;
            padding: 8px 12px;
            font-size: 0.9rem;
        }
        
        .upgrade-btn:hover {
            background: linear-gradient(to bottom, #ab47bc, #8e24aa);
        }

        .wave-preview {
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            text-align: center;
        }

        /* Animations */
        @keyframes pulse-slow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes cannon-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes freeze-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        @keyframes explode {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }
        
        .tower-firing {
            animation: tower-fire 0.2s;
        }
        
        @keyframes tower-fire {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Bug Defense</h1>
            <p>Defend against the bug invasion!</p>
            
            <!-- Audio Controls -->
            <div class="audio-controls">
                <button class="audio-btn" id="mute-btn">üîä</button>
                <button class="audio-btn" id="play-btn">‚ñ∂Ô∏è</button>
            </div>
        </header>
        
        <div class="game-stats">
            <div class="stat">
                <div>Level: <span id="level-display">1</span></div>
            </div>
            <div class="stat">
                <div>Lives: <span id="lives-display">15</span></div>
            </div>
            <div class="stat">
                <div>Money: $<span id="money-display">150</span></div>
            </div>
            <div class="stat">
                <div>Score: <span id="score-display">0</span></div>
            </div>
            <div class="stat">
                <div>Wave: <span id="wave-display">0/10</span></div>
            </div>
        </div>
        
        <div class="game-area">
            <div class="game-board">
                <div id="grid-container">
                    <!-- Game grid will be generated here -->
                </div>
            </div>
            
            <div class="controls">
                <h2>Tower Shop</h2>
                <div class="tower-selection">
                    <div class="tower-option" data-type="basic">
                        <div class="tower-icon" id="basic-tower-icon"></div>
                        <div>Basic Tower</div>
                        <div>Cost: $60</div>
                        <div>Damage: 18</div>
                    </div>
                    <div class="tower-option" data-type="sniper">
                        <div class="tower-icon" id="sniper-tower-icon"></div>
                        <div>Sniper Tower</div>
                        <div>Cost: $120</div>
                        <div>Damage: 50</div>
                    </div>
                    <div class="tower-option" data-type="cannon">
                        <div class="tower-icon" id="cannon-tower-icon"></div>
                        <div>Cannon Tower</div>
                        <div>Cost: $190</div>
                        <div>Damage: 90 + AOE</div>
                    </div>
                    <div class="tower-option" data-type="freeze">
                        <div class="tower-icon" id="freeze-tower-icon"></div>
                        <div>Freeze Tower</div>
                        <div>Cost: $280</div>
                        <div>Slows 60%</div>
                    </div>
                </div>
                
                <div class="placement-help" id="placement-help">
                    Select a tower above, then click on any <span style="color: lightgreen">green area</span> to place it. Avoid <span style="color: #8B4513">brown paths</span>.
                </div>

                <div class="upgrade-section">
                    <h3>Global Upgrades</h3>
                    <button class="upgrade-btn" id="damage-upgrade">Damage +25% $100</button>
                    <button class="upgrade-btn" id="fire-rate-upgrade">Fire Rate +20% $200</button>
                    <button class="upgrade-btn" id="range-upgrade">Range +15% $300</button>
                </div>
                
                <div class="wave-info">
                    <button id="start-wave">Start Wave</button>
                    <div class="wave-preview" id="wave-preview">
                        Next wave: <span id="next-wave-type">Ants</span>
                    </div>
                    <div style="margin-top: 10px;">Enemies: <span id="enemies-remaining">0</span></div>
                </div>
                
                <div class="instructions">
                    <h3>Enemy Types:</h3>
                    <p>‚Ä¢ Caterpillar - Slow but tough</p>
                    <p>‚Ä¢ Ant - Fast and numerous</p>
                    <p>‚Ä¢ Cockroach - Fast and resilient</p>
                    <p>‚Ä¢ Spider - Poisonous</p>
                    <p>‚Ä¢ Grasshopper - High HP</p>
                    <p>‚Ä¢ Tick - Fast and dangerous</p>
                    <p>‚Ä¢ Mosquito - Annoying and fast</p>
                    <p>‚Ä¢ Ladybug - Deceptively strong</p>
                    <p>‚Ä¢ Scorpion - Very tough</p>
                    <p>‚Ä¢ Beetle - Armored and slow</p>
                </div>
            </div>
        </div>
        
        <div class="game-over hidden" id="game-over">
            <h2>Game Over</h2>
            <p>Your final score: <span id="final-score">0</span></p>
            <button id="restart-game">Play Again</button>
        </div>
    </div>

    <script>
      
        // Tower assets
        const ASSETS = {
            towers: {
                basic: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/BugSpray.png",
                sniper: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/BigSprayer.png",
                cannon: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/BugBomb.png",
                freeze: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/GlueTrap.png"
            },
            
            enemies: {
                drainfly: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/DrainFly.png",
                slug: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/Slug.png",
                ant: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/FireAnt.png",
                spider: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/Spider.png",
                millipede: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/Millli.png",
                cockroach: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/Cockroach.png",
                worm: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/Worm.png",
                tick: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/Tick.png",
                mosquito: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/Mosquito.png",
                fly: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/Fly.png",
                termite: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/Termite.png",
                beetle: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/Beetle.png",
                bugbug: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/BugBug.png",
                snail: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/Snail.png",
                daddyspider: "https://github.com/TitanBusinessPros/BugDefense-/raw/main/DaddySpider.png"
            },
            // Music asset - Replace with your single GitHub raw MP3 link
            music: {
                main: "https://raw.githubusercontent.com/yourusername/yourrepo/main/assets/music/game-theme.mp3"
            }
        };
        
        // Game configuration
        const config = {
            gridSize: 12,
            cellSize: 50,
            initialMoney: 160,
            initialLives: 10,
            levels: [
                {
                    waves: 15, // Now 10 waves
                    path: [
                        {x: 0, y: 5}, {x: 3, y: 5}, {x: 3, y: 2}, 
                        {x: 7, y: 2}, {x: 7, y: 7}, {x: 11, y: 7}
                    ]
                }
            ],
            towerTypes: {
                basic: {
                    cost: 60,
                    damage: 35,
                    range: 120,
                    fireRate: 1,
                    color: '#4CAF50',
                    size: 50,
                    projectileType: 'bullet'
                },
                sniper: {
                    cost: 100,
                    damage: 60,
                    range: 200,
                    fireRate: 0.5,
                    color: '#2196F3',
                    size: 50,
                    projectileType: 'sniper'
                },
                cannon: {
                    cost: 190,
                    damage: 200,
                    range: 150,
                    fireRate: 0.2,
                    color: '#FF9800',
                    size: 50,
                    projectileType: 'cannon',
                    splashDamage: true,
                    splashRadius: 80
                },
                freeze: {
                    cost: 280,
                    damage: 30,
                    range: 130,
                    fireRate: 0.5,
                    color: '#00BCD4',
                    size: 50,
                    slow: 0.4,
                    projectileType: 'freeze'
                }
            },
            // Define enemy types with wave patterns - EXPANDED TO 10 ENEMY TYPES
            enemyTypes: [
                { name: 'Ant', baseHealth: 60, speed: 0.03, reward: 15, color: '#8B4513' },
                { name: 'Spider', baseHealth: 90, speed: 0.018, reward: 22, color: '#2F4F4F' },
                { name: 'Slug', baseHealth: 80, speed: 0.02, reward: 20, color: '#228B22' },
                { name: 'Cockroach', baseHealth: 70, speed: 0.025, reward: 18, color: '#8B4513' },
                { name: 'Fly', baseHealth: 40, speed: 0.04, reward: 15, color: '#696969' },
                { name: 'Long Legs', baseHealth: 100, speed: 0.022, reward: 25, color: '#9ACD32' },
                { name: 'Worm', baseHealth: 80, speed: 0.02, reward: 20, color: '#228B22' },
                { name: 'Tick', baseHealth: 50, speed: 0.035, reward: 20, color: '#8B0000' },
                { name: 'Mosquito', baseHealth: 40, speed: 0.04, reward: 15, color: '#696969' },
                { name: 'Snail', baseHealth: 80, speed: 0.02, reward: 20, color: '#228B22' },
                { name: 'Drain Fly', baseHealth: 40, speed: 0.04, reward: 15, color: '#696969' },
                { name: 'Ladybug', baseHealth: 120, speed: 0.015, reward: 30, color: '#FF0000' },
                { name: 'Termite', baseHealth: 150, speed: 0.012, reward: 40, color: '#8B0000' },
                { name: 'Beetle', baseHealth: 200, speed: 0.01, reward: 50, color: '#2F4F4F' },
                { name: 'Bed Bug', baseHealth: 200, speed: 0.01, reward: 50, color: '#2F4F4F' },
                { name: 'Mice', baseHealth: 700, speed: 0.02, reward: 0, color: '#228B22' }
            ]
        };

        // Game state
        let gameState = {
            currentLevel: 0,
            money: config.initialMoney,
            lives: config.initialLives,
            score: 0,
            selectedTower: null,
            towers: [],
            enemies: [],
            projectiles: [],
            wave: 0,
            waveInProgress: false,
            enemiesSpawned: 0,
            enemiesKilled: 0,
            totalEnemies: 0,
            gameOver: false,
            hoverX: -1,
            hoverY: -1,
            upgrades: {
                damage: 1.0,
                fireRate: 1.0,
                range: 1.0
            }
        };

        // Audio state
        let audioState = {
            isMuted: false,
            isPlaying: false,
            audioElement: null
        };

        // DOM elements
        const gridContainer = document.getElementById('grid-container');
        const levelDisplay = document.getElementById('level-display');
        const livesDisplay = document.getElementById('lives-display');
        const moneyDisplay = document.getElementById('money-display');
        const scoreDisplay = document.getElementById('score-display');
        const waveDisplay = document.getElementById('wave-display');
        const enemiesRemainingDisplay = document.getElementById('enemies-remaining');
        const startWaveBtn = document.getElementById('start-wave');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartBtn = document.getElementById('restart-game');
        const towerOptions = document.querySelectorAll('.tower-option');
        const placementHelp = document.getElementById('placement-help');
        const damageUpgradeBtn = document.getElementById('damage-upgrade');
        const fireRateUpgradeBtn = document.getElementById('fire-rate-upgrade');
        const rangeUpgradeBtn = document.getElementById('range-upgrade');
        const wavePreview = document.getElementById('wave-preview');
        const nextWaveType = document.getElementById('next-wave-type');
        
        // Audio controls
        const muteBtn = document.getElementById('mute-btn');
        const playBtn = document.getElementById('play-btn');

        // Initialize the game
        function init() {
            loadAssets();
            createGrid();
            setupAudio();
            updateUI();
            setupEventListeners();
            loadLevel(0);
        }

        // Load custom assets
        function loadAssets() {
            // Set tower icons in the shop
            document.getElementById('basic-tower-icon').style.backgroundImage = `url(${ASSETS.towers.basic})`;
            document.getElementById('sniper-tower-icon').style.backgroundImage = `url(${ASSETS.towers.sniper})`;
            document.getElementById('cannon-tower-icon').style.backgroundImage = `url(${ASSETS.towers.cannon})`;
            document.getElementById('freeze-tower-icon').style.backgroundImage = `url(${ASSETS.towers.freeze})`;
        }

        // Setup audio system
        function setupAudio() {
            // Create audio element
            audioState.audioElement = new Audio();
            audioState.audioElement.loop = true;
            audioState.audioElement.src = ASSETS.music.main;
        }

        // Toggle play/pause
        function togglePlay() {
            if (!audioState.isMuted) {
                if (audioState.isPlaying) {
                    audioState.audioElement.pause();
                    audioState.isPlaying = false;
                    playBtn.textContent = '‚ñ∂Ô∏è';
                } else {
                    audioState.audioElement.play().catch(e => {
                        console.log("Audio play failed:", e);
                    });
                    audioState.isPlaying = true;
                    playBtn.textContent = '‚è∏Ô∏è';
                }
            }
        }

        // Toggle mute
        function toggleMute() {
            audioState.isMuted = !audioState.isMuted;
            audioState.audioElement.muted = audioState.isMuted;
            
            if (audioState.isMuted) {
                muteBtn.textContent = 'üîá';
                // If we mute while playing, pause the audio
                if (audioState.isPlaying) {
                    audioState.audioElement.pause();
                }
            } else {
                muteBtn.textContent = 'üîä';
                // If we unmute and were playing, resume playback
                if (audioState.isPlaying) {
                    audioState.audioElement.play().catch(e => {
                        console.log("Audio play failed:", e);
                    });
                }
            }
        }

        function createGrid() {
            gridContainer.innerHTML = '';
            gridContainer.style.width = `${config.gridSize * config.cellSize}px`;
            gridContainer.style.height = `${config.gridSize * config.cellSize}px`;
            
            for (let y = 0; y < config.gridSize; y++) {
                for (let x = 0; x < config.gridSize; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell grass';
                    cell.style.width = `${config.cellSize}px`;
                    cell.style.height = `${config.cellSize}px`;
                    cell.style.left = `${x * config.cellSize}px`;
                    cell.style.top = `${y * config.cellSize}px`;
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    cell.addEventListener('click', () => handleCellClick(x, y));
                    cell.addEventListener('mouseenter', () => handleCellHover(x, y));
                    gridContainer.appendChild(cell);
                }
            }
        }

        function loadLevel(levelIndex) {
            gameState.currentLevel = levelIndex;
            gameState.wave = 0;
            gameState.waveInProgress = false;
            gameState.enemiesSpawned = 0;
            gameState.enemiesKilled = 0;
            gameState.towers = [];
            gameState.enemies = [];
            gameState.projectiles = [];
            gameState.selectedTower = null;
            
            document.querySelectorAll('.tower, .enemy, .projectile, .tower-range, .explosion').forEach(el => {
                if (el.classList.contains('tower') && !el.classList.contains('range-display')) {
                    el.remove();
                }
            });
            
            // Reset all cells to grass first
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.className = 'grid-cell grass';
            });
            
            const level = config.levels[levelIndex];
            
            // DRAW THE COMPLETE PATH
            const path = level.path;
            
            // Connect ALL points with continuous lines
            for (let i = 0; i < path.length - 1; i++) {
                const start = path[i];
                const end = path[i + 1];
                
                // Draw horizontal line
                if (start.y === end.y) {
                    const minX = Math.min(start.x, end.x);
                    const maxX = Math.max(start.x, end.x);
                    for (let x = minX; x <= maxX; x++) {
                        const cell = getCellAt(x, start.y);
                        if (cell) {
                            cell.className = 'grid-cell path';
                        }
                    }
                }
                // Draw vertical line  
                else if (start.x === end.x) {
                    const minY = Math.min(start.y, end.y);
                    const maxY = Math.max(start.y, end.y);
                    for (let y = minY; y <= maxY; y++) {
                        const cell = getCellAt(start.x, y);
                        if (cell) {
                            cell.className = 'grid-cell path';
                        }
                    }
                }
            }
            
            clearRangeDisplay();
            updateUI();
        }

        function handleCellHover(x, y) {
            gameState.hoverX = x;
            gameState.hoverY = y;
            
            if (gameState.waveInProgress || gameState.gameOver || !gameState.selectedTower) {
                clearRangeDisplay();
                return;
            }
            
            const cell = getCellAt(x, y);
            if (!cell) return;
            
            document.querySelectorAll('.grid-cell.valid, .grid-cell.invalid').forEach(c => {
                c.classList.remove('valid', 'invalid');
            });
            
            const isPath = cell.classList.contains('path');
            const hasTower = gameState.towers.some(t => t.x === x && t.y === y);
            
            if (!isPath && !hasTower) {
                cell.classList.add('valid');
                showTowerRangePreview(x, y);
            } else {
                cell.classList.add('invalid');
                clearRangeDisplay();
            }
        }

        function showTowerRangePreview(x, y) {
            clearRangeDisplay();
            
            const towerType = config.towerTypes[gameState.selectedTower];
            const range = towerType.range * gameState.upgrades.range;
            
            const rangeDisplay = document.createElement('div');
            rangeDisplay.className = 'tower range-display';
            rangeDisplay.style.width = `${range * 2}px`;
            rangeDisplay.style.height = `${range * 2}px`;
            rangeDisplay.style.left = `${x * config.cellSize + config.cellSize/2 - range}px`;
            rangeDisplay.style.top = `${y * config.cellSize + config.cellSize/2 - range}px`;
            
            gridContainer.appendChild(rangeDisplay);
        }

        function clearRangeDisplay() {
            const existingPreview = document.querySelector('.tower.range-display');
            if (existingPreview) existingPreview.remove();
        }

        function handleCellClick(x, y) {
            if (gameState.waveInProgress || gameState.gameOver || !gameState.selectedTower) {
                return;
            }
            
            const cell = getCellAt(x, y);
            if (!cell) return;
            
            const isPath = cell.classList.contains('path');
            const hasTower = gameState.towers.some(t => t.x === x && t.y === y);
            
            if (isPath || hasTower) {
                return;
            }
            
            const towerType = config.towerTypes[gameState.selectedTower];
            if (gameState.money < towerType.cost) {
                return;
            }
            
            gameState.money -= towerType.cost;
            
            const tower = {
                type: gameState.selectedTower,
                x: x,
                y: y,
                damage: towerType.damage * gameState.upgrades.damage,
                range: towerType.range * gameState.upgrades.range,
                fireRate: towerType.fireRate * gameState.upgrades.fireRate,
                lastFired: 0,
                color: towerType.color,
                size: towerType.size,
                slow: towerType.slow,
                projectileType: towerType.projectileType,
                splashDamage: towerType.splashDamage,
                splashRadius: towerType.splashRadius
            };
            
            gameState.towers.push(tower);
            
            const towerElement = document.createElement('div');
            towerElement.className = 'tower';
            towerElement.style.width = `${tower.size}px`;
            towerElement.style.height = `${tower.size}px`;
            towerElement.style.left = `${x * config.cellSize + (config.cellSize - tower.size)/2}px`;
            towerElement.style.top = `${y * config.cellSize + (config.cellSize - tower.size)/2}px`;
            towerElement.style.backgroundImage = `url(${ASSETS.towers[tower.type]})`;
            towerElement.style.backgroundSize = 'contain';
            towerElement.style.backgroundRepeat = 'no-repeat';
            towerElement.style.backgroundPosition = 'center';
            gridContainer.appendChild(towerElement);
            
            document.querySelectorAll('.grid-cell.valid, .grid-cell.invalid').forEach(c => {
                c.classList.remove('valid', 'invalid');
            });
            
            clearRangeDisplay();
            updateUI();
        }

        function startWave() {
            if (gameState.waveInProgress || gameState.gameOver) return;
            
            gameState.wave++;
            gameState.waveInProgress = true;
            gameState.enemiesSpawned = 0;
            gameState.enemiesKilled = 0;
            gameState.totalEnemies = 5 + gameState.wave * 2;
            
            document.querySelectorAll('.grid-cell.valid, .grid-cell.invalid').forEach(c => {
                c.classList.remove('valid', 'invalid');
            });
            clearRangeDisplay();
            
            // Get enemy type for this wave
            const enemyTypeIndex = (gameState.wave - 1) % config.enemyTypes.length;
            const enemyType = config.enemyTypes[enemyTypeIndex];
            
            for (let i = 0; i < gameState.totalEnemies; i++) {
                setTimeout(() => {
                    if (!gameState.gameOver && gameState.waveInProgress) {
                        spawnEnemy(enemyType);
                    }
                }, i * 1500);
            }
            
            updateUI();
        }

        function spawnEnemy(enemyType) {
            const level = config.levels[gameState.currentLevel];
            const path = level.path;
            
            const health = enemyType.baseHealth + (gameState.wave - 1) * 15;
            const speed = enemyType.speed;
            
            const enemy = {
                id: Date.now() + Math.random(),
                x: path[0].x,
                y: path[0].y,
                health: health,
                maxHealth: health,
                speed: speed,
                pathIndex: 0,
                reward: enemyType.reward + gameState.wave * 2,
                slow: 1,
                isSlowed: false,
                name: enemyType.name,
                color: enemyType.color
            };
            
            gameState.enemies.push(enemy);
            gameState.enemiesSpawned++;
            
            const enemyElement = document.createElement('div');
            enemyElement.className = 'enemy';
            enemyElement.id = `enemy-${enemy.id}`;
            enemyElement.style.width = '30px';
            enemyElement.style.height = '30px';
            enemyElement.style.left = `${enemy.x * config.cellSize + 10}px`;
            enemyElement.style.top = `${enemy.y * config.cellSize + 10}px`;
            enemyElement.style.backgroundImage = `url(${ASSETS.enemies[enemy.name.toLowerCase()]})`;
            enemyElement.style.backgroundSize = 'contain';
            enemyElement.style.backgroundRepeat = 'no-repeat';
            enemyElement.style.backgroundPosition = 'center';
            
            const healthBar = document.createElement('div');
            healthBar.className = 'health-bar';
            const healthFill = document.createElement('div');
            healthFill.className = 'health-fill';
            healthFill.style.width = '100%';
            healthBar.appendChild(healthFill);
            enemyElement.appendChild(healthBar);
            
            gridContainer.appendChild(enemyElement);
            
            updateUI();
        }

        function gameLoop() {
            if (gameState.gameOver) return;
            
            moveEnemies();
            fireTowers();
            moveProjectiles();
            checkWaveCompletion();
            
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function moveEnemies() {
            const level = config.levels[gameState.currentLevel];
            const path = level.path;
            
            gameState.enemies.forEach(enemy => {
                if (enemy.pathIndex >= path.length - 1) {
                    gameState.lives--;
                    removeEnemy(enemy.id);
                    if (gameState.lives <= 0) {
                        gameOver();
                    }
                    return;
                }
                
                const target = path[enemy.pathIndex + 1];
                const dx = target.x - enemy.x;
                const dy = target.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 0.1) {
                    enemy.pathIndex++;
                } else {
                    const speed = enemy.speed * enemy.slow;
                    enemy.x += (dx / distance) * speed;
                    enemy.y += (dy / distance) * speed;
                }
                
                const enemyElement = document.getElementById(`enemy-${enemy.id}`);
                if (enemyElement) {
                    enemyElement.style.left = `${enemy.x * config.cellSize + 10}px`;
                    enemyElement.style.top = `${enemy.y * config.cellSize + 10}px`;
                    
                    if (enemy.slow < 1 && !enemy.isSlowed) {
                        enemyElement.classList.add('slowed');
                        enemy.isSlowed = true;
                    } else if (enemy.slow >= 1 && enemy.isSlowed) {
                        enemyElement.classList.remove('slowed');
                        enemy.isSlowed = false;
                    }
                }
            });
        }

        function fireTowers() {
            const now = Date.now();
            
            gameState.towers.forEach(tower => {
                if (now - tower.lastFired < 1000 / tower.fireRate) return;
                
                let target = null;
                let minDistance = tower.range;
                
                gameState.enemies.forEach(enemy => {
                    const dx = (enemy.x + 0.5) - (tower.x + 0.5);
                    const dy = (enemy.y + 0.5) - (tower.y + 0.5);
                    const distance = Math.sqrt(dx * dx + dy * dy) * config.cellSize;
                    
                    if (distance < tower.range) {
                        if (!target || distance < minDistance) {
                            target = enemy;
                            minDistance = distance;
                        }
                    }
                });
                
                if (target) {
                    tower.lastFired = now;
                    
                    const towerElement = document.querySelector(`.tower[style*="left: ${tower.x * config.cellSize + (config.cellSize - tower.size)/2}px"][style*="top: ${tower.y * config.cellSize + (config.cellSize - tower.size)/2}px"]`);
                    if (towerElement) {
                        towerElement.classList.add('tower-firing');
                        setTimeout(() => towerElement.classList.remove('tower-firing'), 200);
                    }
                    
                    const projectile = {
                        id: Date.now() + Math.random(),
                        x: tower.x + 0.5,
                        y: tower.y + 0.5,
                        target: target.id,
                        damage: tower.damage,
                        color: tower.color,
                        slow: tower.slow,
                        type: tower.projectileType,
                        splashDamage: tower.splashDamage,
                        splashRadius: tower.splashRadius
                    };
                    
                    gameState.projectiles.push(projectile);
                    
                    const projectileElement = document.createElement('div');
                    projectileElement.className = `projectile ${projectile.type}`;
                    projectileElement.id = `projectile-${projectile.id}`;
                    projectileElement.style.left = `${tower.x * config.cellSize + config.cellSize/2 - 5}px`;
                    projectileElement.style.top = `${tower.y * config.cellSize + config.cellSize/2 - 5}px`;
                    gridContainer.appendChild(projectileElement);
                }
            });
        }

        function moveProjectiles() {
            gameState.projectiles.forEach((projectile, index) => {
                const targetEnemy = gameState.enemies.find(e => e.id === projectile.target);
                
                if (!targetEnemy) {
                    removeProjectile(projectile.id);
                    return;
                }
                
                const dx = (targetEnemy.x + 0.5) - projectile.x;
                const dy = (targetEnemy.y + 0.5) - projectile.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 0.3) {
                    if (projectile.splashDamage) {
                        createExplosion(projectile.x, projectile.y, projectile.splashRadius);
                        
                        gameState.enemies.forEach(enemy => {
                            const enemyDx = enemy.x - (projectile.x - 0.5);
                            const enemyDy = enemy.y - (projectile.y - 0.5);
                            const enemyDistance = Math.sqrt(enemyDx * enemyDx + enemyDy * enemyDy) * config.cellSize;
                            
                            if (enemyDistance < projectile.splashRadius) {
                                enemy.health -= projectile.damage * 0.5;
                                updateEnemyHealthBar(enemy);
                                
                                if (enemy.health <= 0) {
                                    gameState.money += enemy.reward;
                                    gameState.score += enemy.reward;
                                    removeEnemy(enemy.id);
                                }
                            }
                        });
                    } else {
                        targetEnemy.health -= projectile.damage;
                        
                        if (projectile.slow) {
                            targetEnemy.slow = Math.min(targetEnemy.slow, projectile.slow);
                        }
                        
                        updateEnemyHealthBar(targetEnemy);
                        
                        if (targetEnemy.health <= 0) {
                            gameState.money += targetEnemy.reward;
                            gameState.score += targetEnemy.reward;
                            removeEnemy(targetEnemy.id);
                        }
                    }
                    
                    removeProjectile(projectile.id);
                } else {
                    const speed = projectile.type === 'sniper' ? 0.3 : 0.2;
                    projectile.x += (dx / distance) * speed;
                    projectile.y += (dy / distance) * speed;
                    
                    const projectileElement = document.getElementById(`projectile-${projectile.id}`);
                    if (projectileElement) {
                        projectileElement.style.left = `${projectile.x * config.cellSize - 5}px`;
                        projectileElement.style.top = `${projectile.y * config.cellSize - 5}px`;
                    }
                }
            });
        }

        function createExplosion(x, y, radius) {
            const explosion = document.createElement('div');
            explosion.className = 'explosion';
            explosion.style.width = `${radius * 2}px`;
            explosion.style.height = `${radius * 2}px`;
            explosion.style.left = `${x * config.cellSize - radius}px`;
            explosion.style.top = `${y * config.cellSize - radius}px`;
            
            gridContainer.appendChild(explosion);
            
            setTimeout(() => {
                explosion.remove();
            }, 300);
        }

        function updateEnemyHealthBar(enemy) {
            const enemyElement = document.getElementById(`enemy-${enemy.id}`);
            if (enemyElement) {
                const healthFill = enemyElement.querySelector('.health-fill');
                if (healthFill) {
                    healthFill.style.width = `${(enemy.health / enemy.maxHealth) * 100}%`;
                }
            }
        }

        function checkWaveCompletion() {
            if (gameState.waveInProgress && 
                gameState.enemiesSpawned >= gameState.totalEnemies && 
                gameState.enemies.length === 0) {
                
                gameState.waveInProgress = false;
                gameState.money += 60;
                gameState.score += 150;
                
                updateUI();
            }
        }

        function removeEnemy(id) {
            gameState.enemies = gameState.enemies.filter(e => e.id !== id);
            gameState.enemiesKilled++;
            
            const enemyElement = document.getElementById(`enemy-${id}`);
            if (enemyElement) {
                enemyElement.remove();
            }
        }

        function removeProjectile(id) {
            gameState.projectiles = gameState.projectiles.filter(p => p.id !== id);
            
            const projectileElement = document.getElementById(`projectile-${id}`);
            if (projectileElement) {
                projectileElement.remove();
            }
        }

        function getCellAt(x, y) {
            return document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
        }

        function applyUpgrades() {
            gameState.towers.forEach(tower => {
                const baseType = config.towerTypes[tower.type];
                tower.damage = baseType.damage * gameState.upgrades.damage;
                tower.range = baseType.range * gameState.upgrades.range;
                tower.fireRate = baseType.fireRate * gameState.upgrades.fireRate;
            });
        }

        function updateUI() {
            levelDisplay.textContent = gameState.currentLevel + 1;
            livesDisplay.textContent = gameState.lives;
            moneyDisplay.textContent = gameState.money;
            scoreDisplay.textContent = gameState.score;
            
            const level = config.levels[gameState.currentLevel];
            waveDisplay.textContent = `${gameState.wave}/${level.waves}`;
            enemiesRemainingDisplay.textContent = gameState.enemies.length;
            
            // Update wave preview
            if (!gameState.waveInProgress && gameState.wave < level.waves) {
                const nextWaveTypeIndex = gameState.wave % config.enemyTypes.length;
                const nextEnemyType = config.enemyTypes[nextWaveTypeIndex];
                nextWaveType.textContent = `${nextEnemyType.name}s`;
                wavePreview.style.display = 'block';
            } else {
                wavePreview.style.display = 'none';
            }
            
            towerOptions.forEach(option => {
                const type = option.dataset.type;
                const cost = config.towerTypes[type].cost;
                const isSelected = gameState.selectedTower === type;
                const canAfford = gameState.money >= cost;
                
                option.classList.toggle('selected', isSelected);
                option.style.opacity = canAfford ? '1' : '0.5';
            });
            
            damageUpgradeBtn.disabled = gameState.money < 100;
            fireRateUpgradeBtn.disabled = gameState.money < 100;
            rangeUpgradeBtn.disabled = gameState.money < 100;
            
            if (gameState.selectedTower) {
                const towerType = config.towerTypes[gameState.selectedTower];
                placementHelp.innerHTML = `<strong>${gameState.selectedTower.charAt(0).toUpperCase() + gameState.selectedTower.slice(1)} Tower</strong> selected! Click on any <span style="color: lightgreen">green area</span> to place ($${towerType.cost}).`;
            } else {
                placementHelp.innerHTML = `Select a tower above, then click on any <span style="color: lightgreen">green area</span> to place it. Avoid <span style="color: #8B4513">brown paths</span>.`;
            }
            
            startWaveBtn.disabled = gameState.waveInProgress || gameState.gameOver;
            startWaveBtn.textContent = gameState.waveInProgress ? 'Wave In Progress...' : 'Start Wave';
        }

        function gameOver() {
            gameState.gameOver = true;
            gameOverScreen.classList.remove('hidden');
            finalScoreDisplay.textContent = gameState.score;
        }

        function setupEventListeners() {
            towerOptions.forEach(option => {
                option.addEventListener('click', () => {
                    const type = option.dataset.type;
                    const cost = config.towerTypes[type].cost;
                    
                    if (gameState.money >= cost) {
                        gameState.selectedTower = type;
                        updateUI();
                        
                        if (gameState.hoverX !== -1 && gameState.hoverY !== -1) {
                            handleCellHover(gameState.hoverX, gameState.hoverY);
                        }
                    }
                });
            });
            
            damageUpgradeBtn.addEventListener('click', () => {
                if (gameState.money >= 80) {
                    gameState.money -= 80;
                    gameState.upgrades.damage *= 1.25;
                    applyUpgrades();
                    updateUI();
                }
            });
            
            fireRateUpgradeBtn.addEventListener('click', () => {
                if (gameState.money >= 70) {
                    gameState.money -= 70;
                    gameState.upgrades.fireRate *= 1.2;
                    applyUpgrades();
                    updateUI();
                }
            });
            
            rangeUpgradeBtn.addEventListener('click', () => {
                if (gameState.money >= 60) {
                    gameState.money -= 60;
                    gameState.upgrades.range *= 1.15;
                    applyUpgrades();
                    updateUI();
                }
            });
            
            startWaveBtn.addEventListener('click', startWave);
            
            // Audio controls
            muteBtn.addEventListener('click', toggleMute);
            playBtn.addEventListener('click', togglePlay);
            
            restartBtn.addEventListener('click', () => {
                gameState = {
                    currentLevel: 0,
                    money: config.initialMoney,
                    lives: config.initialLives,
                    score: 0,
                    selectedTower: null,
                    towers: [],
                    enemies: [],
                    projectiles: [],
                    wave: 0,
                    waveInProgress: false,
                    enemiesSpawned: 0,
                    enemiesKilled: 0,
                    totalEnemies: 0,
                    gameOver: false,
                    hoverX: -1,
                    hoverY: -1,
                    upgrades: {
                        damage: 1.0,
                        fireRate: 1.0,
                        range: 1.0
                    }
                };
                
                gameOverScreen.classList.add('hidden');
                loadLevel(0);
                gameLoop();
            });
        }

        // Start the game
        init();
        gameLoop();
    </script>
</body>
</html>
bg game.html
Displaying bg game.html.
